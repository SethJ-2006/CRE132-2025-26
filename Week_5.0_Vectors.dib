#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Vectors

## 1. Physics and Life!

Congratulations on your good progress so far! You've mastered the fundamentals of object-oriented programming. Now comes the exciting part: **bringing your objects to life with realistic physics!**

Previously, we learned to create objects. In Week 4, we'll learn to make them move, bounce, attract each other, and behave like real physical entities. This is where programming becomes magical - when mathematical concepts create visually stunning, lifelike behaviors.

**This Week's Journey:**
- ðŸ§® **Vectors**: The mathematical foundation of all movement
- ðŸš€ **Physics Objects**: Things that move with velocity and acceleration  
- ðŸ’¨ **Forces**: Wind, gravity, attraction, and repulsion
- ðŸ’¥ **Collisions**: Realistic bouncing and interactions
- ðŸŽ® **Complete Game**: Putting it all together in Pong

---

#!markdown

As a taster - run the random walk code below and examine the code.

#!csharp

#r "nuget: Raylib-cs, 7.0.1"

#!csharp

using System;
using System.Collections.Generic;
using Raylib_cs;
using static Raylib_cs.Raylib;
using static Raylib_cs.KeyboardKey;
using System.Numerics;

int walkSpeed = 1;
int dotSize = 1; // Define the dot size

// Initialize the window
const int screenWidth = 800;
const int screenHeight = 600;
Raylib.InitWindow(screenWidth, screenHeight, "Raylib [C#] - Random Walk");

Vector2 position = new Vector2(screenWidth / 2, screenHeight / 2);

// Set the target FPS
// Raylib.SetTargetFPS(120);

while (!WindowShouldClose())
{
    BeginDrawing();
    // ClearBackground(Color.White);

    RandomWalk(ref position, screenWidth, screenHeight);
    
    EndDrawing();
}

CloseWindow();

// Function to generate a random number
int RandomNumber(int min, int max)
{
    Random random = new Random();
    return random.Next(min, max);
}

// Function to generate a random color
Color RandomColor()
{
    return new Color((byte)RandomNumber(0, 255), (byte)RandomNumber(0, 255), (byte)RandomNumber(0, 255), (byte)255);
}

// Function to generate a random direction
Vector2 RandomDirection()
{
    Vector2 direction;
    direction = new Vector2(RandomNumber(-1, 2), RandomNumber(-1, 2));
    return direction;
}

// Function to generate a random position between 0 and the screen width/height
Vector2 RandomPosition(int width, int height)
{
    return new Vector2(RandomNumber(0, width), RandomNumber(0, height));
}

// Function to generate a random walk
void RandomWalk(ref Vector2 position, int screenWidth, int screenHeight)
{
    Vector2 direction = RandomDirection();

    // Move the position
    position.X += direction.X * walkSpeed;
    position.Y += direction.Y * walkSpeed;

    // Ensure the position stays within the window bounds
    if (position.X < 0) position.X = 0;
    if (position.X > screenWidth) position.X = screenWidth;
    if (position.Y < 0) position.Y = 0;
    if (position.Y > screenHeight) position.Y = screenHeight;

    Color color = RandomColor();

    // Draw the current position
    DrawCircle((int)position.X, (int)position.Y, dotSize, Color.White);
}

#!markdown

## 2. What Are Vectors? The Language of Movement

In real life, when you say "I'm going to the shop," you need two pieces of information:
- **Direction**: Which way to go (north, east, etc.)
- **Distance**: How far to travel (2 blocks, 500 meters, etc.)

In programming, a **vector** captures both pieces of information in a single mathematical object. It's like an arrow that points somewhere with a specific length.

### Vector Applications in Games:
- **Position**: Where an object is located (x, y coordinates)
- **Velocity**: How fast and in what direction an object is moving
- **Acceleration**: How the velocity is changing over time
- **Forces**: Pushes and pulls that affect motion (gravity, wind, explosions)

---

## 3. Understanding Vectors Through Code

Let's start with the basics - what vectors look like in C#:

#!csharp

using System;

// Simple 2D Vector class - we'll build our own first to understand the concepts
public class Vector2D
{
    public float X;
    public float Y;
    
    // Constructor
    public Vector2D(float x, float y)
    {
        X = x;
        Y = y;
    }
    
    // Display the vector
    public override string ToString()
    {
        return $"({X:F2}, {Y:F2})";
    }
    
    // Calculate the magnitude (length) of the vector
    public float Magnitude()
    {
        return (float)Math.Sqrt(X * X + Y * Y);
    }
    
    // Create a unit vector (direction only, length = 1)
    public Vector2D Normalize()
    {
        float mag = Magnitude();
        if (mag > 0)
        {
            return new Vector2D(X / mag, Y / mag);
        }
        return new Vector2D(0, 0);
    }
}

// Let's explore vectors!
Console.WriteLine("=== Understanding Vectors ===");

// Position vectors - where things are
Vector2D playerPosition = new Vector2D(100, 200);
Vector2D enemyPosition = new Vector2D(300, 150);

Console.WriteLine($"Player is at: {playerPosition}");
Console.WriteLine($"Enemy is at: {enemyPosition}");

// Velocity vectors - how things are moving
Vector2D playerVelocity = new Vector2D(5, 0);     // Moving right at 5 units per frame
Vector2D bulletVelocity = new Vector2D(0, -10);   // Moving up at 10 units per frame

Console.WriteLine($"Player velocity: {playerVelocity}");
Console.WriteLine($"Bullet velocity: {bulletVelocity}");

// Magnitude tells us the speed
Console.WriteLine($"Player speed: {playerVelocity.Magnitude():F2} units per frame");
Console.WriteLine($"Bullet speed: {bulletVelocity.Magnitude():F2} units per frame");

// Direction vectors - which way to go
Vector2D rightDirection = new Vector2D(1, 0);
Vector2D upDirection = new Vector2D(0, -1);   // Remember: Y goes down in screen coordinates
Vector2D diagonalDirection = new Vector2D(1, 1).Normalize();

Console.WriteLine($"Right direction (normalized): {rightDirection}");
Console.WriteLine($"Up direction (normalized): {upDirection}");
Console.WriteLine($"Diagonal direction (normalized): {diagonalDirection}");

#!markdown

**Key Insights:**
- âœ… **Position vectors** tell us where objects are in 2D space
- âœ… **Velocity vectors** tell us how fast and in what direction objects are moving
- âœ… **Magnitude** is the length of the vector (the speed for velocity vectors)
- âœ… **Normalized vectors** have length 1 and represent pure direction

---

## 4. Vector Arithmetic: The Magic of Movement

Vectors become powerful when we can do math with them. Let's add vector arithmetic to our class:

#!csharp

// Enhanced Vector2D with arithmetic operations
public class Vector2D
{
    public float X;
    public float Y;
    
    public Vector2D(float x, float y)
    {
        X = x;
        Y = y;
    }
    
    // Vector addition - combine vectors
    public Vector2D Add(Vector2D other)
    {
        return new Vector2D(X + other.X, Y + other.Y);
    }
    
    // Vector subtraction - find difference between vectors
    public Vector2D Subtract(Vector2D other)
    {
        return new Vector2D(X - other.X, Y - other.Y);
    }
    
    // Scalar multiplication - scale a vector
    public Vector2D Multiply(float scalar)
    {
        return new Vector2D(X * scalar, Y * scalar);
    }
    
    // Scalar division - shrink a vector
    public Vector2D Divide(float scalar)
    {
        if (scalar != 0)
        {
            return new Vector2D(X / scalar, Y / scalar);
        }
        return new Vector2D(0, 0);
    }
    
    public float Magnitude()
    {
        return (float)Math.Sqrt(X * X + Y * Y);
    }
    
    public Vector2D Normalize()
    {
        float mag = Magnitude();
        if (mag > 0)
        {
            return Divide(mag);
        }
        return new Vector2D(0, 0);
    }
    
    public override string ToString()
    {
        return $"({X:F2}, {Y:F2})";
    }
}

// Demonstrate vector arithmetic with real movement
Console.WriteLine("=== Vector Arithmetic in Action ===");

// A ball's position and velocity
Vector2D ballPosition = new Vector2D(50, 100);
Vector2D ballVelocity = new Vector2D(3, -2);

Console.WriteLine($"Starting position: {ballPosition}");
Console.WriteLine($"Velocity: {ballVelocity}");

// Simulate 5 frames of movement
for (int frame = 1; frame <= 5; frame++)
{
    // Movement = Position + Velocity (vector addition!)
    ballPosition = ballPosition.Add(ballVelocity);
    Console.WriteLine($"Frame {frame}: Ball at {ballPosition}");
}

Console.WriteLine("\n=== Force Application ===");

// A spaceship affected by gravity
Vector2D shipPosition = new Vector2D(400, 200);
Vector2D shipVelocity = new Vector2D(2, 0);   // Moving right
Vector2D gravity = new Vector2D(0, 0.1f);     // Weak downward force

Console.WriteLine($"Ship starts at: {shipPosition} with velocity: {shipVelocity}");

// Simulate physics: velocity changes due to forces, position changes due to velocity
for (int frame = 1; frame <= 8; frame++)
{
    // Apply force to velocity (vector addition)
    shipVelocity = shipVelocity.Add(gravity);
    
    // Apply velocity to position (vector addition)
    shipPosition = shipPosition.Add(shipVelocity);
    
    Console.WriteLine($"Frame {frame}: Ship at {shipPosition}, velocity: {shipVelocity}");
}

#!markdown

**The Physics Loop Revealed:**
1. **Forces** change **velocity** (acceleration)
2. **Velocity** changes **position** (movement)
3. Repeat every frame for realistic motion!

This is the foundation of all game physics engines.

---

## 5. Visual Vectors: Seeing Movement in Raylib

Now let's see vectors in action with visual examples. This is where the math becomes beautiful:

#!csharp

#r "nuget: Raylib-cs, 7.0.1"

#!csharp

using Raylib_cs;
using System;

// Let's use System.Numerics.Vector2 for Raylib integration
using System.Numerics;

// Simple moving object using vectors
public class MovingBall
{
    public Vector2 Position;
    public Vector2 Velocity;
    public float Radius;
    public Color BallColor;
    
    public MovingBall(float x, float y, float vx, float vy, Color color)
    {
        Position = new Vector2(x, y);
        Velocity = new Vector2(vx, vy);
        Radius = 15;
        BallColor = color;
    }
    
    public void Update()
    {
        // The fundamental physics equation: Position += Velocity
        Position += Velocity;
        
        // Bounce off screen edges
        if (Position.X <= Radius || Position.X >= 800 - Radius)
        {
            Velocity = new Vector2(-Velocity.X, Velocity.Y);  // Reverse X velocity
        }
        if (Position.Y <= Radius || Position.Y >= 600 - Radius)
        {
            Velocity = new Vector2(Velocity.X, -Velocity.Y);  // Reverse Y velocity
        }
        
        // Keep on screen
        Position = new Vector2(
            Math.Clamp(Position.X, Radius, 800 - Radius),
            Math.Clamp(Position.Y, Radius, 600 - Radius)
        );
    }
    
    public void Draw()
    {
        // Draw the ball
        Raylib.DrawCircleV(Position, Radius, BallColor);
        
        // Draw velocity vector as an arrow (for educational purposes)
        Vector2 velocityEnd = Position + (Velocity * 10); // Scale up to make visible
        Raylib.DrawLineV(Position, velocityEnd, Color.White);
        
        // Draw arrowhead
        Vector2 arrowDirection = Vector2.Normalize(Velocity);
        if (arrowDirection.Length() > 0)
        {
            Vector2 arrowLeft = Vector2.Transform(arrowDirection, Matrix3x2.CreateRotation(-0.5f)) * 8;
            Vector2 arrowRight = Vector2.Transform(arrowDirection, Matrix3x2.CreateRotation(0.5f)) * 8;
            
            Raylib.DrawLineV(velocityEnd, velocityEnd - arrowLeft, Color.White);
            Raylib.DrawLineV(velocityEnd, velocityEnd - arrowRight, Color.White);
        }
    }
}

// Create some bouncing balls with different velocities
MovingBall ball1 = new MovingBall(100, 100, 4, 3, Color.Red);
MovingBall ball2 = new MovingBall(200, 200, -3, 2, Color.Blue);
MovingBall ball3 = new MovingBall(300, 300, 2, -4, Color.Green);

Raylib.InitWindow(800, 600, "Vectors in Motion - Watch the White Arrows!");
Raylib.SetTargetFPS(60);

while (!Raylib.WindowShouldClose())
{
    // Update all balls
    ball1.Update();
    ball2.Update();
    ball3.Update();
    
    // Drawing
    Raylib.BeginDrawing();
    Raylib.ClearBackground(Color.Black);
    
    // Draw all balls with their velocity vectors
    ball1.Draw();
    ball2.Draw();
    ball3.Draw();
    
    // Instructions
    Raylib.DrawText("White arrows show velocity vectors", 10, 10, 20, Color.White);
    Raylib.DrawText("Notice how arrows change direction when bouncing", 10, 35, 16, Color.LightGray);
    Raylib.DrawText("The arrow length shows speed", 10, 55, 16, Color.LightGray);
    
    Raylib.EndDrawing();
}

Raylib.CloseWindow();

#!markdown

**ðŸŽ¯ Visual Learning:**
- **White arrows** represent velocity vectors in real-time
- **Arrow direction** shows where the ball is heading
- **Arrow length** indicates speed (longer = faster)
- **Direction changes** when bouncing off walls demonstrate vector reversal

This visualization helps you *see* the mathematics in action!

---

## 6. The Nature of Code: Acceleration and Forces

Now we'll implement the core concept from Daniel Shiffman's "Nature of Code" - objects that respond to forces:

#!csharp

using System.Numerics;

// Mover class inspired by Nature of Code
public class Mover
{
    public Vector2 Position;
    public Vector2 Velocity;
    public Vector2 Acceleration;
    public float Mass;
    public float Radius;
    public Color MoverColor;
    
    public Mover(float x, float y, float mass)
    {
        Position = new Vector2(x, y);
        Velocity = Vector2.Zero;
        Acceleration = Vector2.Zero;
        Mass = mass;
        Radius = mass * 5; // Visual size based on mass
        MoverColor = Color.Purple;
    }
    
    // Apply a force to this mover (F = ma, so a = F/m)
    public void ApplyForce(Vector2 force)
    {
        Vector2 acceleration = force / Mass;
        Acceleration += acceleration;
    }
    
    // Update physics every frame
    public void Update()
    {
        // Velocity changes by acceleration
        Velocity += Acceleration;
        
        // Position changes by velocity
        Position += Velocity;
        
        // Clear acceleration (forces are applied fresh each frame)
        Acceleration = Vector2.Zero;
        
        // Limit velocity to prevent runaway speed
        if (Velocity.Length() > 10)
        {
            Velocity = Vector2.Normalize(Velocity) * 10;
        }
    }
    
    public void Draw()
    {
        Raylib.DrawCircleV(Position, Radius, MoverColor);
        Raylib.DrawCircleLinesV(Position, Radius, Color.White);
        
        // Draw velocity vector
        if (Velocity.Length() > 0.1f)
        {
            Vector2 velocityEnd = Position + (Velocity * 15);
            Raylib.DrawLineV(Position, velocityEnd, Color.Yellow);
        }
    }
    
    // Keep mover on screen with wrapping
    public void CheckEdges()
    {
        if (Position.X > 800) Position = new Vector2(0, Position.Y);
        if (Position.X < 0) Position = new Vector2(800, Position.Y);
        if (Position.Y > 600) Position = new Vector2(Position.X, 0);
        if (Position.Y < 0) Position = new Vector2(Position.X, 600);
    }
}

// Demo: Mover affected by different forces
Mover heavyMover = new Mover(200, 300, 5);   // Heavy object
Mover lightMover = new Mover(600, 300, 2);   // Light object

Raylib.InitWindow(800, 600, "Nature of Code - Forces and Acceleration");
Raylib.SetTargetFPS(60);

while (!Raylib.WindowShouldClose())
{
    // Define forces
    Vector2 wind = new Vector2(0.1f, 0);        // Constant rightward wind
    Vector2 gravity = new Vector2(0, 0.2f);     // Downward gravity
    
    // Apply forces to both movers
    heavyMover.ApplyForce(wind);
    heavyMover.ApplyForce(gravity * heavyMover.Mass); // Gravity proportional to mass
    
    lightMover.ApplyForce(wind);
    lightMover.ApplyForce(gravity * lightMover.Mass);
    
    // Mouse attraction force
    Vector2 mousePos = new Vector2(Raylib.GetMouseX(), Raylib.GetMouseY());
    
    // Calculate attraction to mouse (simplified)
    Vector2 attractionHeavy = Vector2.Normalize(mousePos - heavyMover.Position) * 0.5f;
    Vector2 attractionLight = Vector2.Normalize(mousePos - lightMover.Position) * 0.5f;
    
    if (Vector2.Distance(mousePos, heavyMover.Position) < 100)
        heavyMover.ApplyForce(attractionHeavy);
    if (Vector2.Distance(mousePos, lightMover.Position) < 100)
        lightMover.ApplyForce(attractionLight);
    
    // Update physics
    heavyMover.Update();
    lightMover.Update();
    
    // Handle screen edges
    heavyMover.CheckEdges();
    lightMover.CheckEdges();
    
    // Drawing
    Raylib.BeginDrawing();
    Raylib.ClearBackground(Color.DarkBlue);
    
    heavyMover.Draw();
    lightMover.Draw();
    
    // Draw mouse position
    Raylib.DrawCircle(Raylib.GetMouseX(), Raylib.GetMouseY(), 5, Color.Red);
    
    // Instructions
    Raylib.DrawText("Forces: Wind (right), Gravity (down), Mouse Attraction", 10, 10, 16, Color.White);
    Raylib.DrawText("Heavy object (left) vs Light object (right)", 10, 30, 16, Color.LightGray);
    Raylib.DrawText("Move mouse near objects to attract them", 10, 50, 16, Color.LightGray);
    Raylib.DrawText("Yellow arrows = velocity vectors", 10, 70, 16, Color.Yellow);
    
    Raylib.EndDrawing();
}

Raylib.CloseWindow();

#!markdown

**ðŸŒªï¸ Nature of Code in Action:**
- **Multiple forces** affect the same object simultaneously
- **Mass matters**: Heavy objects are less affected by the same force
- **Mouse attraction**: Interactive forces based on distance
- **Realistic physics**: Objects accelerate and decelerate naturally
- **Emergent behavior**: Complex motion from simple force rules

---

## 7. Challenge: Create Your Own Vector-Based Systems

Your turn! These challenges will test your understanding of vectors and physics:

### Challenge 1: Gravitational System ðŸª
**Your Task**: Create a mini solar system with gravitational attraction.

**Requirements:**
- **Sun**: Large, stationary object at screen center
- **Planets**: Smaller objects that orbit around the sun
- **Gravitational Force**: `F = G * (m1 * m2) / distanceÂ²`
- **Orbital Motion**: Circular or elliptical paths based on initial velocity

**Physics Implementation:**
- Calculate distance between sun and each planet
- Apply gravitational force toward the sun
- Vary planet masses for different orbital speeds
- Start planets with initial sideways velocity for orbits

#!csharp

using System.Numerics;
using Raylib_cs;

// TODO: Create your gravitational system classes
// Consider: Sun (stationary), Planet (orbiting), GravitationalField

// Gravitational constant (you can adjust this for visual effect)
const float G = 50.0f;

// TODO: Implement gravitational force calculation
// Force direction: from planet toward sun
// Force magnitude: G * sunMass * planetMass / (distance * distance)

// TODO: Create multiple planets with different:
// - Masses (affects orbital speed)
// - Starting positions (affects orbit size) 
// - Initial velocities (affects orbit shape)

Console.WriteLine("Create your solar system here!");
Console.WriteLine("Experiment with different masses and initial velocities.");

#!markdown

**Expected Behavior:**
- Planets should orbit the sun in smooth paths
- Heavier planets should orbit more slowly
- Different starting velocities should create different orbit shapes
- System should be stable (planets don't fly away or crash)

---

### Challenge 2: Particle System with Forces ðŸŽ†
**Your Task**: Create a fireworks-like particle system with realistic physics.

**Requirements:**
- **Particles**: Small objects affected by multiple forces
- **Gravity**: Pulls particles downward over time
- **Wind**: Sideways force that varies over time
- **Friction**: Gradually slows particles down
- **Lifespan**: Particles fade out and disappear

**Visual Features:**
- Particles spawn with random initial velocities
- Different colors for different particle types
- Fading alpha as particles age
- Smooth, natural-looking motion

#!csharp

// TODO: Create your particle system
// Consider: Particle class, ParticleSystem manager, various forces

// TODO: Forces to implement:
// - Gravity: constant downward force
// - Wind: variable sideways force (maybe sine wave?)
// - Air resistance: force opposite to velocity
// - Random turbulence: small random forces

// TODO: Particle properties:
// - Position, Velocity, Acceleration (vectors)
// - Life, MaxLife (for fading)
// - Color, Size
// - Mass (affects force response)

Console.WriteLine("Build your particle system here!");
Console.WriteLine("Click to spawn particles, watch them react to forces.");

#!markdown

---

### Challenge 3: Flocking Behavior ðŸ¦
**Your Task**: Implement Craig Reynolds' flocking algorithm using vectors.

**Requirements:**
- **Boids**: Objects that move in groups (like birds or fish)
- **Separation**: Avoid crowding neighbors
- **Alignment**: Steer toward average heading of neighbors  
- **Cohesion**: Steer toward average position of neighbors
- **Emergent Flocking**: Natural group behavior from simple rules

**Flocking Rules (as forces):**
1. **Separation**: Calculate force away from too-close neighbors
2. **Alignment**: Calculate force toward average neighbor velocity
3. **Cohesion**: Calculate force toward average neighbor position
4. **Combine**: Add all forces and apply to acceleration

#!csharp

// TODO: Create your flocking system
// Consider: Boid class, Flock manager, neighbor detection

// TODO: For each boid, calculate:
// - Nearby neighbors (within certain distance)
// - Separation force (avoid crowding)
// - Alignment force (match group direction)
// - Cohesion force (move toward group center)

// TODO: Combine forces with different weights:
// - Separation might be strongest (avoid collisions)
// - Alignment creates group movement
// - Cohesion keeps group together

Console.WriteLine("Implement flocking behavior here!");
Console.WriteLine("Start with 10-20 boids and watch emergent behavior.");

#!markdown

**Success Criteria:**
- Boids move in coordinated groups
- No collisions between boids
- Natural-looking flocking patterns emerge
- Groups can split and merge dynamically

---

## 8. Challenge Reflection

After completing your vector-based challenges, consider:

1. **Physics Understanding**: How did implementing vector math change your understanding of movement and forces?

2. **Emergent Behavior**: What unexpected behaviors emerged from your simple force rules?

3. **Performance**: With many objects calculating forces, did you notice any performance impacts?

4. **Visual Beauty**: How do mathematical concepts translate into visually appealing motion?

5. **Real-world Applications**: Where else might these vector concepts apply in game development?

---

## 9. What's Next: Building on Vector Foundations

You've now mastered the mathematical foundation of all game physics! In our upcoming sessions, we'll build on these vector concepts:

- **Session 20**: Create sophisticated Mover objects with complex behaviors
- **Session 21**: Implement advanced force systems (springs, attractions, magnetic fields)
- **Session 22**: Add collision detection to our physics objects
- **Session 23**: Create realistic bouncing and energy transfer
- **Session 24**: Build a complete physics-based game (Pong)

**Your Vector Toolkit** now includes:
- âœ… **Mathematical foundation**: Understanding position, velocity, acceleration
- âœ… **Vector arithmetic**: Addition, subtraction, scaling, normalization
- âœ… **Physics loops**: How forces create realistic motion
- âœ… **Visual representation**: Seeing vectors as arrows and motion paths
- âœ… **Nature of Code concepts**: Emergent behavior from simple rules

---

## Key Concepts Mastered:
- **Vector Fundamentals**: Position, velocity, acceleration as vectors
- **Vector Arithmetic**: Mathematical operations that create movement
- **Physics Loops**: Force â†’ Acceleration â†’ Velocity â†’ Position
- **Visual Vectors**: Seeing mathematics as motion and arrows
- **Multiple Forces**: How different forces combine naturally
- **Emergent Behavior**: Complex motion from simple mathematical rules
- **Nature of Code**: Inspiration from natural systems and physics

**Outstanding work mastering vectors! You've unlocked the mathematical language that powers all realistic movement and physics in games. The foundation you've built here will support everything from simple bouncing balls to complex fluid simulations!** ðŸš€ðŸ§®âœ¨
