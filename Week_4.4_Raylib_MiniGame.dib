#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Week 3, Session 18: Raylib - Multiple Objects

## 1. Bringing It All Together

Congratulations! You've reached the final session of Week 3. Over the past sessions, you've learned:

- **Session 16**: Classes & Objects - Creating blueprints and instances
- **Session 17**: Data Collections - Managing multiple items with arrays and lists

Now it's time to combine these powerful concepts and create something truly impressive: **a complete game with multiple interactive objects**!

By the end of this session, you'll have built a mini-game featuring:
- üéÆ Player-controlled character
- üëπ Multiple enemies with AI behavior  
- üíé Collectible items that spawn and disappear
- üí• Collision detection between all objects
- üåü Visual effects and game juice
- üèÜ Score system and win/lose conditions

This is where object-oriented programming really shines in game development!

---

## 2. Game Architecture: Multiple Object Systems

Professional games manage hundreds or thousands of objects simultaneously. Here's how we organize them:

### Object Categories:
- **Player Objects**: Controlled by human input
- **Enemy Objects**: Controlled by AI logic
- **Collectible Objects**: Items to be gathered
- **Projectile Objects**: Bullets, missiles, etc.
- **Effect Objects**: Particles, explosions, visual feedback

### Management Pattern:
```csharp
List<Enemy> enemies = new List<Enemy>();
List<Collectible> collectibles = new List<Collectible>();
List<Particle> effects = new List<Particle>();

// Game loop pattern:
while (!Raylib.WindowShouldClose())
{
    UpdatePlayer();
    UpdateEnemies();
    UpdateCollectibles();
    UpdateEffects();
    CheckCollisions();
    RemoveInactiveObjects();
    DrawEverything();
}
```

---

## 3. Collision Detection: The Heart of Interaction

Before we build our game, we need to understand how objects interact. **Collision detection** determines when objects touch each other.

### Simple Circle Collision:
Two circles collide when the distance between their centers is less than the sum of their radii.

#!csharp

using System;

// Simple collision detection function
public static bool CirclesCollide(float x1, float y1, float radius1, float x2, float y2, float radius2)
{
    float deltaX = x1 - x2;
    float deltaY = y1 - y2;
    float distance = (float)Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
    
    return distance < (radius1 + radius2);
}

// Test the collision detection
Console.WriteLine("=== Collision Detection Tests ===");

// Test 1: Overlapping circles
bool collision1 = CirclesCollide(100, 100, 20, 110, 110, 20);
Console.WriteLine($"Circles at (100,100) and (110,110) with radius 20: {(collision1 ? "COLLISION" : "No collision")}");

// Test 2: Distant circles  
bool collision2 = CirclesCollide(100, 100, 20, 200, 200, 20);
Console.WriteLine($"Circles at (100,100) and (200,200) with radius 20: {(collision2 ? "COLLISION" : "No collision")}");

// Test 3: Just touching
bool collision3 = CirclesCollide(100, 100, 20, 140, 100, 20);
Console.WriteLine($"Circles at (100,100) and (140,100) with radius 20: {(collision3 ? "COLLISION" : "No collision")}");

#!markdown

**Understanding the Math**: The distance formula `‚àö((x1-x2)¬≤ + (y1-y2)¬≤)` calculates the straight-line distance between two points. If this distance is less than both radii combined, the circles overlap!

---

## 4. Building Our Game Objects

Let's create the classes for our multi-object game. Each class will be focused and well-designed:

#!csharp

#r "nuget: Raylib-cs, 7.0.1"

#!csharp

using Raylib_cs;
using System.Collections.Generic;
using System;

// Player class - controlled by human input
public class Player
{
    public float X, Y;
    public float Speed;
    public Color PlayerColor;
    public float Radius;
    public int Health;
    public int Score;
    
    public Player(float startX, float startY)
    {
        X = startX;
        Y = startY;
        Speed = 4.0f;
        PlayerColor = Color.Blue;
        Radius = 20;
        Health = 100;
        Score = 0;
    }
    
    public void Update()
    {
        // Handle input
        if (Raylib.IsKeyDown(KeyboardKey.W) || Raylib.IsKeyDown(KeyboardKey.Up)) Y -= Speed;
        if (Raylib.IsKeyDown(KeyboardKey.S) || Raylib.IsKeyDown(KeyboardKey.Down)) Y += Speed;
        if (Raylib.IsKeyDown(KeyboardKey.A) || Raylib.IsKeyDown(KeyboardKey.Left)) X -= Speed;
        if (Raylib.IsKeyDown(KeyboardKey.D) || Raylib.IsKeyDown(KeyboardKey.Right)) X += Speed;
        
        // Keep player on screen
        if (X < Radius) X = Radius;
        if (X > 800 - Radius) X = 800 - Radius;
        if (Y < Radius) Y = Radius;
        if (Y > 600 - Radius) Y = 600 - Radius;
    }
    
    public void Draw()
    {
        Raylib.DrawCircle((int)X, (int)Y, Radius, PlayerColor);
        Raylib.DrawCircleLines((int)X, (int)Y, Radius, Color.White);
        
        // Draw health bar
        float healthPercent = Health / 100.0f;
        int barWidth = (int)(40 * healthPercent);
        Raylib.DrawRectangle((int)X - 20, (int)Y - 35, 40, 6, Color.Red);
        Raylib.DrawRectangle((int)X - 20, (int)Y - 35, barWidth, 6, Color.Green);
    }
    
    public bool CollidesWith(float otherX, float otherY, float otherRadius)
    {
        float deltaX = X - otherX;
        float deltaY = Y - otherY;
        float distance = (float)Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
        return distance < (Radius + otherRadius);
    }
}

// Enemy class - controlled by simple AI
public class Enemy
{
    public float X, Y;
    public float SpeedX, SpeedY;
    public Color EnemyColor;
    public float Radius;
    public bool IsActive;
    public static readonly Color DarkRed = new Color(139, 0, 0, 255); // Custom DarkRed
    
    public Enemy(float startX, float startY)
    {
        X = startX;
        Y = startY;
        SpeedX = Raylib.GetRandomValue(-2, 2);
        SpeedY = Raylib.GetRandomValue(-2, 2);
        EnemyColor = Color.Red;
        Radius = 15;
        IsActive = true;
    }
    
    public void Update()
    {
        // Simple bouncing movement
        X += SpeedX;
        Y += SpeedY;
        
        // Bounce off walls
        if (X <= Radius || X >= 800 - Radius) SpeedX = -SpeedX;
        if (Y <= Radius || Y >= 600 - Radius) SpeedY = -SpeedY;
        
        // Keep on screen
        if (X < Radius) X = Radius;
        if (X > 800 - Radius) X = 800 - Radius;
        if (Y < Radius) Y = Radius;
        if (Y > 600 - Radius) Y = 600 - Radius;
    }
    
    public void Draw()
    {
        if (IsActive)
        {
            Raylib.DrawCircle((int)X, (int)Y, Radius, EnemyColor);
            Raylib.DrawCircleLines((int)X, (int)Y, Radius, DarkRed);
        }
    }
    
    public bool CollidesWith(float otherX, float otherY, float otherRadius)
    {
        if (!IsActive) return false;
        
        float deltaX = X - otherX;
        float deltaY = Y - otherY;
        float distance = (float)Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
        return distance < (Radius + otherRadius);
    }
}

// Collectible class - items to gather
public class Collectible
{
    public float X, Y;
    public Color ItemColor;
    public float Radius;
    public bool IsCollected;
    public int Value;
    public float BobOffset; // For floating animation
    
    public Collectible(float startX, float startY, int value)
    {
        X = startX;
        Y = startY;
        ItemColor = Color.Gold;
        Radius = 12;
        IsCollected = false;
        Value = value;
        BobOffset = Raylib.GetRandomValue(0, 360);
    }
    
    public void Update()
    {
        // Gentle floating animation
        BobOffset += 2.0f;
        if (BobOffset > 360) BobOffset = 0;
    }
    
    public void Draw()
    {
        if (!IsCollected)
        {
            float floatY = Y + (float)Math.Sin(BobOffset * Math.PI / 180) * 3;
            Raylib.DrawCircle((int)X, (int)floatY, Radius, ItemColor);
            Raylib.DrawCircleLines((int)X, (int)floatY, Radius, Color.Orange);
            
            // Draw sparkle effect
            if (Raylib.GetRandomValue(1, 30) == 1)
            {
                Raylib.DrawCircle((int)X + Raylib.GetRandomValue(-5, 5), 
                                (int)floatY + Raylib.GetRandomValue(-5, 5), 
                                2, Color.White);
            }
        }
    }
    
    public bool CollidesWith(float otherX, float otherY, float otherRadius)
    {
        if (IsCollected) return false;
        
        float floatY = Y + (float)Math.Sin(BobOffset * Math.PI / 180) * 3;
        float deltaX = X - otherX;
        float deltaY = floatY - otherY;
        float distance = (float)Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
        return distance < (Radius + otherRadius);
    }
}

#!markdown

**Notice the Design Patterns:**
- ‚úÖ Each class has a clear **responsibility** (Player = input, Enemy = AI, Collectible = items)
- ‚úÖ All classes share similar **methods** (Update, Draw, CollidesWith)
- ‚úÖ Each class manages its own **state** (position, color, active status)
- ‚úÖ **Collision detection** is built into each class for easy checking

---

## 5. Complete Mini-Game: "Orb Collector"

Now let's put it all together into a complete game! This demonstrates professional game architecture:

#!csharp

// Game state and objects
Player player = new Player(400, 300);
List<Enemy> enemies = new List<Enemy>();
List<Collectible> collectibles = new List<Collectible>();

// Game settings
int targetScore = 100;
bool gameWon = false;
bool gameLost = false;
int enemySpawnTimer = 0;
int collectibleSpawnTimer = 0;

// Initialize some starting objects
for (int i = 0; i < 3; i++)
{
    enemies.Add(new Enemy(Raylib.GetRandomValue(50, 750), Raylib.GetRandomValue(50, 550)));
}

for (int i = 0; i < 5; i++)
{
    collectibles.Add(new Collectible(Raylib.GetRandomValue(100, 700), Raylib.GetRandomValue(100, 500), 10));
}

// Main game loop
Raylib.InitWindow(800, 600, "Orb Collector - Multiple Objects Demo");
Raylib.SetTargetFPS(60);

while (!Raylib.WindowShouldClose())
{
    if (!gameWon && !gameLost)
    {
        // Update player
        player.Update();
        
        // Update all enemies
        foreach (Enemy enemy in enemies)
        {
            enemy.Update();
        }
        
        // Update all collectibles
        foreach (Collectible collectible in collectibles)
        {
            collectible.Update();
        }
        
        // Check player vs enemies collision
        foreach (Enemy enemy in enemies)
        {
            if (enemy.CollidesWith(player.X, player.Y, player.Radius))
            {
                player.Health -= 1; // Damage over time
                if (player.Health <= 0)
                {
                    gameLost = true;
                }
            }
        }
        
        // Check player vs collectibles collision
        for (int i = collectibles.Count - 1; i >= 0; i--)
        {
            if (collectibles[i].CollidesWith(player.X, player.Y, player.Radius))
            {
                player.Score += collectibles[i].Value;
                collectibles.RemoveAt(i);
                
                if (player.Score >= targetScore)
                {
                    gameWon = true;
                }
            }
        }
        
        // Spawn new enemies occasionally
        enemySpawnTimer++;
        if (enemySpawnTimer > 300 && enemies.Count < 8) // Every 5 seconds
        {
            enemies.Add(new Enemy(Raylib.GetRandomValue(50, 750), Raylib.GetRandomValue(50, 550)));
            enemySpawnTimer = 0;
        }
        
        // Spawn new collectibles occasionally
        collectibleSpawnTimer++;
        if (collectibleSpawnTimer > 180 && collectibles.Count < 10) // Every 3 seconds
        {
            collectibles.Add(new Collectible(Raylib.GetRandomValue(100, 700), Raylib.GetRandomValue(100, 500), 10));
            collectibleSpawnTimer = 0;
        }
    }
    
    // Drawing
    Raylib.BeginDrawing();
    Raylib.ClearBackground(Color.DarkGreen);
    
    // Draw all objects
    player.Draw();
    
    foreach (Enemy enemy in enemies)
    {
        enemy.Draw();
    }
    
    foreach (Collectible collectible in collectibles)
    {
        collectible.Draw();
    }
    
    // Draw UI
    Raylib.DrawText($"Score: {player.Score}/{targetScore}", 10, 10, 24, Color.White);
    Raylib.DrawText($"Health: {player.Health}", 10, 40, 20, Color.White);
    Raylib.DrawText($"Enemies: {enemies.Count}", 10, 65, 16, Color.White);
    Raylib.DrawText($"Collectibles: {collectibles.Count}", 10, 85, 16, Color.White);
    
    if (gameWon)
    {
        Raylib.DrawRectangle(0, 0, 800, 600, Raylib.ColorAlpha(Color.Green, 0.7f));
        Raylib.DrawText("YOU WIN!", 300, 250, 48, Color.White);
        Raylib.DrawText("Collected enough orbs!", 280, 320, 24, Color.White);
    }
    else if (gameLost)
    {
        Raylib.DrawRectangle(0, 0, 800, 600, Raylib.ColorAlpha(Color.Red, 0.7f));
        Raylib.DrawText("GAME OVER", 280, 250, 48, Color.White);
        Raylib.DrawText("Health depleted!", 320, 320, 24, Color.White);
    }
    else
    {
        Raylib.DrawText("WASD/Arrows to move", 600, 10, 16, Color.LightGray);
        Raylib.DrawText("Avoid red enemies", 600, 30, 16, Color.LightGray);
        Raylib.DrawText("Collect gold orbs", 600, 50, 16, Color.LightGray);
    }
    
    Raylib.EndDrawing();
}

Raylib.CloseWindow();

#!markdown

**üéÆ Amazing! You've Built a Complete Game!**

This game demonstrates all the key concepts of object-oriented game programming:
- ‚úÖ **Multiple object types** working together
- ‚úÖ **Dynamic object creation** and destruction
- ‚úÖ **Collision detection** between all objects
- ‚úÖ **Game state management** (win/lose conditions)
- ‚úÖ **Real-time object updates** and rendering
- ‚úÖ **Professional game architecture** patterns

**üîß Common Raylib-cs Issue**: If you get an error about `Color.Fade` not existing, use `Raylib.ColorAlpha(color, alpha)` instead. The `Fade` method was renamed in newer versions of Raylib-cs.

---

## 6. Nature of Code: Adding Emergent Behavior

Let's enhance our enemies with more sophisticated AI inspired by the "Nature of Code". We'll add **flocking behavior** - enemies that move toward the player!

#!csharp

// Enhanced Enemy with seeking behavior
public class SmartEnemy : Enemy
{
    private float SeekSpeed;
    private float MaxSpeed;
    
    public SmartEnemy(float startX, float startY) : base(startX, startY)
    {
        SeekSpeed = 0.5f;
        MaxSpeed = 1.5f;
        EnemyColor = Color.Purple;
    }
    
    public void SeekPlayer(float playerX, float playerY)
    {
        // Calculate direction to player
        float deltaX = playerX - X;
        float deltaY = playerY - Y;
        float distance = (float)Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > 0)
        {
            // Normalize direction and apply seeking speed
            float dirX = (deltaX / distance) * SeekSpeed;
            float dirY = (deltaY / distance) * SeekSpeed;
            
            // Add to current velocity
            SpeedX += dirX;
            SpeedY += dirY;
            
            // Limit maximum speed
            float currentSpeed = (float)Math.Sqrt(SpeedX * SpeedX + SpeedY * SpeedY);
            if (currentSpeed > MaxSpeed)
            {
                SpeedX = (SpeedX / currentSpeed) * MaxSpeed;
                SpeedY = (SpeedY / currentSpeed) * MaxSpeed;
            }
        }
    }
    
    public new void Update(float playerX, float playerY)
    {
        SeekPlayer(playerX, playerY);
        base.Update(); // Call parent Update for movement
    }
}

// Quick demo of seeking behavior
Console.WriteLine("=== Smart Enemy Seeking Demo ===");

SmartEnemy smartEnemy = new SmartEnemy(100, 100);
float playerX = 400, playerY = 300;

Console.WriteLine($"Initial enemy position: ({smartEnemy.X}, {smartEnemy.Y})");
Console.WriteLine($"Player position: ({playerX}, {playerY})");

// Simulate several updates
for (int i = 0; i < 10; i++)
{
    smartEnemy.Update(playerX, playerY);
    Console.WriteLine($"Update {i + 1}: Enemy at ({smartEnemy.X:F1}, {smartEnemy.Y:F1})");
}

#!markdown

**Nature of Code Concepts Applied:**
- ‚úÖ **Seeking**: Enemies actively move toward targets
- ‚úÖ **Vector Mathematics**: Calculating direction and magnitude
- ‚úÖ **Emergent Behavior**: Simple rules create complex-looking AI
- ‚úÖ **Steering Forces**: Gradual acceleration toward goals

---

## 7. Challenge: Build Your Own Multi-Object Game

Your turn! Create a complete game that demonstrates mastery of multiple object management:

### Challenge 1: "Asteroid Field" üöÄ
**Your Task**: Create a space-themed game with multiple object types.

**Requirements:**
- **Player**: Ship controlled by arrow keys, can shoot bullets
- **Asteroids**: Large objects that bounce around the screen
- **Bullets**: Player projectiles that destroy asteroids
- **PowerUps**: Items that boost player abilities
- **Collision System**: All objects interact appropriately

**Game Mechanics:**
- Player shoots bullets with spacebar
- Bullets destroy asteroids on contact
- Asteroids damage player on contact
- PowerUps improve player (faster shooting, bigger bullets, etc.)
- Score increases when asteroids are destroyed
- Game ends when player health reaches zero

#!csharp

using Raylib_cs;
using System.Collections.Generic;

// TODO: Create your Bullet class
// Properties: X, Y, SpeedX, SpeedY, IsActive, Radius
// Methods: Update() (move bullet), Draw(), CollidesWith()

// TODO: Create your Asteroid class  
// Properties: X, Y, SpeedX, SpeedY, Radius, Health, IsActive
// Methods: Update() (move and bounce), Draw(), CollidesWith(), TakeDamage()

// TODO: Create your PowerUp class
// Properties: X, Y, PowerType (enum?), IsCollected, Radius
// Methods: Update(), Draw(), CollidesWith()

// TODO: Enhanced Player class that can shoot
// Add: List<Bullet> bullets, shooting cooldown, Shoot() method

// TODO: Game loop with all object management
// - Update all object types
// - Check all collision combinations
// - Spawn new objects periodically
// - Remove destroyed objects
// - Handle win/lose conditions

Console.WriteLine("Create your Asteroid Field game here!");
Console.WriteLine("Use the classes and patterns from the examples above.");

#!markdown

---

### Challenge 2: "Ecosystem Simulation" üåø
**Your Task**: Create a nature simulation with predator-prey relationships.

**Requirements:**
- **Prey Animals**: Move around, flee from predators, reproduce when safe
- **Predator Animals**: Hunt prey, need food to survive, die if they don't eat
- **Food Sources**: Plants that grow over time, provide energy
- **Environment**: Boundaries, obstacles, or terrain features

**Advanced Behaviors:**
- Prey animals seek food and avoid predators
- Predators seek prey and avoid starvation
- Population dynamics (birth/death based on conditions)
- Visual indicators for hunger, fear, etc.

#!csharp

// TODO: Create ecosystem classes
// Consider: Prey, Predator, Food, Environment
// Implement: Seeking, fleeing, energy systems, reproduction

Console.WriteLine("Design your ecosystem simulation!");
Console.WriteLine("This is an advanced challenge - start simple and add complexity.");

#!markdown

---

### Challenge 3: "Tower Defense Core" üè∞
**Your Task**: Create the foundation of a tower defense game.

**Requirements:**
- **Enemies**: Follow a path from start to end
- **Towers**: Static objects that shoot at nearby enemies
- **Projectiles**: Tower bullets that travel toward targets
- **Path System**: Enemies follow waypoints
- **Range Detection**: Towers only shoot enemies within range

**Game Systems:**
- Wave spawning (groups of enemies)
- Tower placement and upgrade
- Resource management (money/points)
- Health system (player loses health when enemies reach end)

#!csharp

// TODO: Create tower defense classes
// Consider: Enemy, Tower, Projectile, Waypoint, GameManager
// Implement: Pathfinding, targeting, resource management

Console.WriteLine("Build your tower defense foundation!");
Console.WriteLine("Focus on solid object architecture - graphics can be simple.");

#!markdown

---

## 8. Challenge Reflection

After completing your multi-object game, consider these questions:

1. **Architecture**: How did you organize your different object types? What patterns emerged?

2. **Collision Systems**: What collision combinations did you need to handle? How did you optimize the checking?

3. **Object Lifecycle**: How did you manage creating and destroying objects during gameplay?

4. **Performance**: With many objects active, did you notice any performance issues? How might you optimize?

5. **Emergent Behavior**: Did any unexpected or interesting behaviors emerge from the interactions between your objects?

---

## 9. Week 3 Completion: What You've Mastered

Congratulations! You've completed Week 3 and mastered the foundations of object-oriented game programming:

### **Core Programming Concepts:**
- ‚úÖ **Classes & Objects**: Creating blueprints and instances
- ‚úÖ **Data Collections**: Arrays for fixed data, Lists for dynamic data  
- ‚úÖ **Object Management**: Creating, updating, and destroying objects
- ‚úÖ **Collision Detection**: Making objects interact meaningfully
- ‚úÖ **Game Architecture**: Professional patterns for complex systems

### **Game Development Skills:**
- ‚úÖ **Multiple Object Systems**: Managing different types simultaneously
- ‚úÖ **Real-time Updates**: Handling input, logic, and rendering each frame
- ‚úÖ **State Management**: Win/lose conditions and game flow
- ‚úÖ **Visual Effects**: Animations, particle effects, and game juice
- ‚úÖ **User Interface**: Displaying game information clearly

### **Problem-Solving Abilities:**
- ‚úÖ **System Design**: Breaking complex problems into manageable classes
- ‚úÖ **Debugging**: Finding and fixing issues in multi-object systems
- ‚úÖ **Optimization**: Writing efficient code for real-time performance
- ‚úÖ **Creativity**: Combining technical skills with game design

---

## 10. Looking Ahead: Week 4 and Beyond

You're now ready for advanced game programming concepts! In Week 4, you'll explore:

- **Physics Systems**: Realistic movement, gravity, and forces
- **Advanced AI**: Pathfinding, state machines, and decision trees
- **Visual Effects**: Particle systems, shaders, and advanced graphics
- **Game Polish**: Audio, animations, and user experience
- **Performance**: Optimization techniques for complex games

**Your Foundation is Solid**: The object-oriented principles you've mastered this week are the same ones used in professional game engines like Unity, Unreal, and Godot. You're building real industry skills!

---

## Key Concepts Mastered:
- **Multi-Object Architecture**: Professional game structure patterns
- **Collision Systems**: Detecting and responding to object interactions  
- **Dynamic Object Management**: Creating, updating, and destroying objects
- **Game State Systems**: Win/lose conditions and flow control
- **Real-time Performance**: Handling many objects at 60 FPS
- **Nature of Code Integration**: Emergent behaviors from simple rules
- **Complete Game Development**: From concept to playable game

**Outstanding work completing Week 3! You've transformed from a programming beginner into someone who can create complex, interactive games with multiple systems working together!** üéÆüèÜüöÄ
